#!/bin/python

import sys
import os
from typing import TextIO, List

import validators

# TODO
# documentatie:
# - [ ] Nederlandse (+engelse?) documentatie, en het script in het Engels
# - [ ] URL validation
# - [ ] create getter/setter methods for isrepresentatievan info
# - [x] check length of naam
# - [ ] make sure to allow multiple values when "unbounded"
# - [ ] fish/bash autocomplete
#   - i think the best approach is supply these as files on git
#   - this might be useful https://github.com/kislyuk/argcomplete
# - [ ] make a informatieobject subclass, and Object parent class
#   - This way, the script becomes more useful, as it can also generate other .xml files
# - [ ] write unit tests
# - [ ] write setup.py script

MAX_NAAM_LENGTH = 80

class Bestand:
    """MDTO Bestand class"""

    def __init__(self,
                 infile: TextIO,
                 identificatiekenmerken: List[str] | str,
                 identificatiebronnen: List[str] | str,
                 informatieobject: TextIO,
                 outfile: TextIO,
                 naam: str = None,
                 url: str = None,
                 quiet: bool = False,
                 force: bool = False):
        """Create a new Bestand object.

        Args:
          infile: file-like object that serves as the input file
          identificatiekenmerken: str or list of str for <identificatieKenmerk> tags
          identificatiebronnen: str or list of str for <identificatieBron> tags
          informatieobject: file-like object serving as corresponding informatieobject
          output: file-like object to write to (defaults to stdout when invoked from cli)
          naam: value of <naam>. Defaults to the basename of the input file
          url: value of <URLBestand>
          quiet: silence non-fatal warnings
          force: do not exit when encountering invalid tag values
        """

        if quiet:
            self.log = lambda: None
        else:
            self.log = lambda m: print(m, file=sys.stderr)

        self.force = force

        self.identificatiekenmerken = identificatiekenmerken
        self.identificatiebronnen = identificatiebronnen

        if len(self.identificatiekenmerken) != len(self.identificatiebronnen):
            self.error("number of 'identificatieKenmerk' tags differs from "
                       "number of 'identificatieBron' tags")
        if naam:
            self.naam = naam
        else:
            self.naam = os.path.basename(infile.name)

        self.url = url

    @property
    def naam(self):
        """Value of MDTO 'naam' tag.

        Defaults to: the name of the input file.
        Valid value: any string of up to 80 characters in length
        MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/naam
        """
        return self._naam

    @naam.setter
    def naam(self, val):
        if len(val) > MAX_NAAM_LENGTH:
            self.warn(f"value '{val}' of attribute 'naam' "
                      "exceeds maximum length of {MAX_NAAM_LENGTH}")
        self._naam = val

    @property
    def identificatiekenmerken(self):
        """Value(s) of MDTO 'identificatieKenmerk' tag(s).

        Valid value(s): any string or list of strings
        MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/identificatieKenmerk
        """
        return self._identificatiekenmerken

    @identificatiekenmerken.setter
    def identificatiekenmerken(self, val):
        # Note that, here, there's no check if len(kenmerken) matches len(bronnen).
        # However, such a check  might not be useful anyway,  
        # as self.kenmerken and self.bronnen cannot be updated simultaneously.
        # Lets just that hope validation checks against the .xsd catch this.

        # allow setting this to a string
        if isinstance(val, str):
            self._identificatiekenmerken = [val]
        elif isinstance(val, list):
            self._identificatiekenmerken = val
        else:
            self.error(f"{type(val)} is not a valid type for <identificatieKenmerk>")

    @property
    def identificatiebronnen(self):
        """Value(s) of MDTO 'identificatieBron' tag(s).

        Valid value(s): any string or list of strings
        MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/identificatieBron
        """
        return self._identificatiebronnen

    @identificatiebronnen.setter
    def identificatiebronnen(self, val):
        # allow setting this to a string
        if isinstance(val, str):
            self._identificatiebronnen = [val]
        elif isinstance(val, list):
            self._identificatiebronnen = val
        else:
            self.error(f"{type(val)} is not a valid type for <identificatieBron>")

    @property
    def url(self):
        """Value of MDTO 'URLBestand' tag.

        Valid value: any RFC 3986 compliant URI
        MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/URLBestand
        """
        return self._url

    @url.setter
    def url(self, val):
        # url can be non-existant
        if val is None:
            self._url = None
        elif validators.url(val):
            self._url = val
        else:
            self.warn(f"URL {val} is malformed.")

    # Helper methods
    def warn(self, warning):
        """Print warning, and exit if self.force is not set"""

        orange = '\033[33m'
        esc_end = '\033[0m'

        warning = f"{orange}Warning: {warning} "
        warning += "Skipping." if self.force else "Exiting."
        warning += esc_end

        self.log(warning)
        if not self.force:
            sys.exit(-1)

    def error(self, error):
        """Print error and exit"""

        red = '\033[31m'
        esc_end = '\033[0m'

        self.log(f"{red}Error: {error}{esc_end}")
        sys.exit(-1)

if __name__ == "__main__":

    import argparse

    bb = '\033[1m'
    be = '\033[0m'
    parser = argparse.ArgumentParser(
        description="Create a 'MDTO Bestand' .xml file based on the characteristics of your input FILE.\n"
        'The value of most XML tags will be inferred automatically, but some need to be specified manually.\n\n'
        f'{bb}Example:{be} mdto img001.jpg --identificatiekenmerk 34c5-43a --identificatiebron "Corsa (DMS)" --informatieobject 103.xml',
        formatter_class=argparse.RawTextHelpFormatter,
        epilog="For more information, see https://www.nationaalarchief.nl/archiveren/mdto/bestand")

    parser.add_argument('infile', metavar='FILE', type=argparse.FileType('r'),
                        help='file for which a MDTO Bestand .xml file should be generated')
    parser.add_argument('--identificatiekenmerk', '-k', metavar='KENMERK', required=True,
                        action='append',
                        help='value of <identificatieKenmerk>. Can be specified multiple times')
    parser.add_argument('--identificatiebron', '-b', metavar='BRON', required=True,
                        action='append',
                        help='value of <identificatieBron>. Can be specified multiple times')
    parser.add_argument('--informatieobject', '-O', metavar="INFORMATIEOBJECT.xml", required=True,
                        type=argparse.FileType('r'),
                        help='path to corresponding informatieobject. '
                        'Used to infer values of <isRepresentatieVan>')

    # optionals
    # nargs='?' means 'use value of default when nothing given'
    parser.add_argument('--output', '-o', metavar="OUTPUT.xml", nargs='?',
                        type=argparse.FileType('w'), default=sys.stdout,
                        help='file to write to (default: print to stdout)')
    parser.add_argument('--url', '-u',
                        help='value of <URLBestand>. Needs to be a RFC 3986 compliant URI')
    parser.add_argument('--naam', '-n',
                        help='override <naam> with custom value')
    parser.add_argument('--quiet', '-q', action='store_true',
                        help='silence non-fatal warnings')
    parser.add_argument('--force', '-f', action='store_true',
                        help="do not exit when a tag's value conflicts with the MDTO spec. "
                        "Might produce non-compliant files")

    args = parser.parse_args()

    bestand = Bestand(infile=args.infile, identificatiekenmerken=args.identificatiekenmerk,
                      identificatiebronnen=args.identificatiebron, informatieobject=args.informatieobject,
                      outfile=args.output, naam=args.naam, url=args.url,
                      quiet=args.quiet, force=args.force)
