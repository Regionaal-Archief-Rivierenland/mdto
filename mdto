#!/bin/python

import sys
import os
import shutil
import subprocess
import hashlib
from typing import TextIO, List
from datetime import datetime
from lxml import etree
from dataclasses import dataclass

# Make into an optional dependency?
import validators

# TODO

# - [ ] ❗ make most classes into a dataclasses, using the @dataclass decorator
#   - https://docs.python.org/3/library/dataclasses.html
#   - for docstrings, see https://stackoverflow.com/questions/51125415/how-do-i-document-a-constructor-for-a-class-using-python-dataclasses
#     - may be nice if some doc info from the .xsd would be visible in docstring
# - [x] vraag Leon naar verschillende IDs bij Bestand & Informatieobject
# - [x] python library rfc3987: may seem useful, but too permissive
# - [ ] Nederlandse (+engelse?) documentatie, en het script in het Engels
#   - make a nice ascii cast!
# - [x] URL validation
# - [ ] try siegfried instead of fido for speed?
#   - https://openpreservation.org/blogs/siegfried-pronom-based-file-format-identification-tool/
#   - also, fido lacks behind the pronom spec; .wacz are not recognized for example  
# - [x] check length of naam
# - [x] make sure to allow multiple values when "unbounded"
# - [ ] fish/bash autocomplete
#   - i think the best approach is supply these as files on git
#   - this might be useful https://github.com/kislyuk/argcomplete
# - [ ] make a informatieobject subclass, and Object parent class
#   - This way, the script becomes more useful, as it can also generate other .xml files
# - [ ] write unit tests
# - [ ] write setup.py script

MAX_NAAM_LENGTH = 80

@dataclass
class IdentificatieGegevens:
    """MDTO identificatieGegevens class

    MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/identificatieGegevens

    Args:
        identificatieKenmerk (str): Een kenmerk waarmee een object geïdentificeerd kan worden
        identificatieBron (str): Herkomst van het kenmerk
    """
    identificatieKenmerk: str
    identificatieBron: str

    def to_xml(self, root: str) -> etree._Element:
        """Transform object into XML tree

        Args:
            root: name of the elements' new parent tag

        Returns:
            lxml tree
        """

        root = etree.Element(root)

        kenmerk = etree.SubElement(root, "identificatieKenmerk")
        kenmerk.text = self.identificatieKenmerk

        bron = etree.SubElement(root, "identificatieBron")
        bron.text = self.identificatieBron

        return root

@dataclass
class VerwijzingGegevens:
    """MDTO verwijzingGegevens class

    MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/verwijzingGegevens

    Args:
        verwijzingNaam (str): De naam van het object waarnaar verwezen wordt
        verwijzingIdentificatie (IdentificatieGegevens): De identificatie van het object waarnaar verwezen wordt
    """
    verwijzingNaam: str
    verwijzingIdentificatie: IdentificatieGegevens = None

    def to_xml(self, root) -> etree._Element:
        """Transform object into XML tree

        Args:
            root: name of the elements' parent tag

        Returns:
            lxml tree element
        """
        
        root = etree.Element(root)
        
        verwijzingnaam = etree.SubElement(root, "verwijzingNaam")
        verwijzingnaam.text = self.verwijzingNaam

        if self.verwijzingIdentificatie:
            # append lxml element directly to tree, 
            # and set name of the root element to 'verwijzingIdentificatie'
            root.append(
                self.verwijzingIdentificatie.to_xml("verwijzingIdentificatie"))
        
        return root

@dataclass
class BegripGegevens:
    """MDTO begripGegevens class

    MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/begripGegevens
    
    Args:
        begripLabel (str): De tekstweergave van het begrip dat is toegekend in de begrippenlijst
        begripBegrippenlijst (VerwijzingGegevens): Verwijzing naar een beschrijving van de begrippen
        begripCode (str): De code die aan het begrip is toegekend in de begrippenlijst
    """
    begripLabel: str,
    begripBegrippenlijst: VerwijzingGegevens,
    begripCode: str = None 

    def to_xml(self, root) -> etree._Element:
        """Transform object into XML tree

        Args:
            root: name of the elements' parent tag

        Returns:
            lxml tree element
        """
        
        root = etree.Element(root)
        
        begriplabel = etree.SubElement(root, "begripLabel")
        begriplabel.text = self.begripLabel

        if begripcode:
            begripcode = etree.SubElement(root, "begripCode")
            begripcode.text = self.begripCode

        root.append(
            self.begripBegrippenlijst.to_xml("begripBegrippenlijst"))
        
        return root

class ChecksumGegevens:
    """MDTO checksumGegevens class

    MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/checksumGegevens
    """
    
    def __init__(self, infile: TextIO, algorithm: str='sha256'):
        """Create a new checksumGegevens object.         
        Values for checksumAlgoritme, checksumWaarde, and checksumDatum are generated automatically.
        
        Args:
            infile (TextIO): file-like object to generate checksum data for
            algorithm (str): checksum algorithm to use; defaults to sha256. For valid values, see https://docs.python.org/3/library/hashlib.html
        """

        verwijzing = VerwijzingGegevens(
            verwijzingNaam='Begrippenlijst ChecksumAlgoritme MDTO')

        self.checksumAlgoritme = BegripGegevens(
            begripLabel=algorithm.upper(), begripBegrippenlijst=verwijzing)

        # file_digest() expects a file in binary mode, hence `infile.buffer.raw`
        # FIXME: this value is not the same on each call?
        self.checksumWaarde = hashlib.file_digest(infile.buffer.raw,
                                                  algorithm).hexdigest()

        self.checksumDatum = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")

        def to_xml(self, root) -> etree._Element:
            """Transform object into XML tree

            Args:
                root: name of the elements' parent tag

            Returns:
                lxml tree element
        """

        root = etree.Element(root)

        root.append(
                self.checksumAlgoritme.to_xml("checksumAlgoritme"))
        

        bron = etree.SubElement(root, "identificatieBron")
        bron.text = self.identificatieBron

        return root

class Bestand:
    """MDTO Bestand class"""

    def __init__(self,
                 infile: TextIO,
                 identificatiekenmerken: List[str] | str,
                 identificatiebronnen: List[str] | str,
                 informatieobject: TextIO,
                 naam: str = None,
                 url: str = None,
                 quiet: bool = False,
                 force: bool = False):
        """Create a new Bestand object.

        Args:
            infile: file-like object that serves as the input file
            identificatiekenmerken: str or list of str for <identificatieKenmerk> tags
            identificatiebronnen: str or list of str for <identificatieBron> tags
            informatieobject: file-like object serving as corresponding informatieobject
            naam: value of <naam>. Defaults to the basename of the input file
            url: value of <URLBestand>
            quiet: silence non-fatal warnings
            force: do not exit when encountering invalid tag values
        """

        if quiet:
            self.log = lambda: None
        else:
            self.log = lambda m: print(m, file=sys.stderr)

        self.force = force

        # file needs to be in read-only mode
        if infile.writable():
            infile.close()
            infile = open(infile.name, 'r')

        if len(identificatiekenmerken) != len(identificatiebronnen):
            self.error("number of 'identificatieKenmerk' tags differs from "
                       "number of 'identificatieBron' tags")

        # permit setting kenmerk and bron to a string
        if isinstance(identificatiekenmerken, str):
            identificatiekenmerken = [identificatiekenmerken]
        if isinstance(identificatiebronnen, str):
            identificatiebronnen = [identificatiebronnen]

        self.ids = [IdentificatieGegevens(k, b) 
                    for k, b in zip(identificatiekenmerken, identificatiebronnen)]

        if naam:
            self.naam = naam
        else:
            self.naam = os.path.basename(infile.name)

        self.url = url

        self.omvang = os.path.getsize(infile.name)
        self.bestandsformaat = self.pronominfo(infile.name)
        
        infile.close()

    def to_xml(self):
        """Transform object into XML tree

        Returns:
            lxml tree element
        """
        return ""

    def pronominfo(self, path: str) -> BegripGegevens:
        # FIXME: format more properly
        """Use fido library to generate PRONOM information about a file.
        This information can be used in the <bestandsformaat> tag.

        Args:
            path: the file to inspect

        Returns:
            ``BegripGegevens`` object with the following properties::
                {
                    `begripLabel`: file's PRONOM signature name
                    `begripCode`: file's PRONOM ID
                    `begripBegrippenLijst`: reference to PRONOM registry
                }
        """

        # Note: fido currently lacks a public API
        # Hence, the most robust solution is to invoke fido as a cli program
        # Upstream issue: https://github.com/openpreserve/fido/issues/94
        # downside is that this is slow, maybe siegfried speeds things up?

        # check if fido program exists
        if not shutil.which('fido'):
            self.error("'fido' not found. For installation instructions, "
                       "see https://github.com/openpreserve/fido#installation")

        cmd = ['fido', '-q', '-matchprintf', 'OK,%(info.formatname)s,%(info.puid)s,\n',
               '-nomatchprintf', 'FAIL', path]
        cmd_result = subprocess.run(cmd, capture_output=True,
                                    shell=False, text=True, check=True)
        stdout = cmd_result.stdout
        stderr = cmd_result.stderr
        returncode = cmd_result.returncode

        if '(empty)' in stderr.lower():
            self.warn(f"file {path} appears to be an empty file!")

        if returncode != 0:
            self.warn(f"fido PRONOM detection on file {path} "
                      f"failed with error '{stderr}'.")
        elif stdout.startswith("OK"):
            results = stdout.split('\n')
            if len(results) > 2: # .split('\n') returns a list of two items
                self.log("Info: fido returned more than one PRONOM match "
                         f"for file {path}. Selecting the first one.")

            # strip "OK" from the output
            results = results[0].split(",")[1:]
            verwijzing = VerwijzingGegevens(verwijzingNaam="PRONOM-register")
            return BegripGegevens(begripLabel=results[0],
                                  begripCode=results[1],
                                  begripBegrippenlijst=verwijzing)
        else:
            self.warn(f"fido failed to detect PRONOM ID of file {path}.")

        # can return None in case PRONOM detection fails and force == True
        return None

    @property
    def naam(self):
        """Value of MDTO 'naam' tag.

        Defaults to: the name of the input file.
        Valid value: any string of up to 80 characters in length
        MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/naam
        """
        return self._naam

    @naam.setter
    def naam(self, val):
        if len(val) > MAX_NAAM_LENGTH:
            self.warn(f"value '{val}' of attribute 'naam' "
                      "exceeds maximum length of {MAX_NAAM_LENGTH}")
        self._naam = val

    @property
    def url(self):
        """Value of MDTO 'URLBestand' tag.

        Valid value: any RFC 3986 compliant URI
        MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/URLBestand
        """
        return self._url

    @url.setter
    def url(self, val):
        # url can be non-existant
        if val is None:
            self._url = None
        elif validators.url(val):
            self._url = val
        else:
            self.warn(f"URL {val} is malformed.")

    # Helper methods
    def warn(self, warning):
        """Print warning, and exit if self.force is not set"""

        orange = '\033[33m'
        esc_end = '\033[0m'

        warning = f"{orange}Warning: {warning} "
        warning += "Skipping." if self.force else "Exiting."
        warning += esc_end

        self.log(warning)
        if not self.force:
            sys.exit(-1)

    def error(self, error):
        """Print error and exit"""

        red = '\033[31m'
        esc_end = '\033[0m'

        self.log(f"{red}Error: {error}{esc_end}")
        sys.exit(-1)

if __name__ == "__main__":

    import argparse

    bb = '\033[1m'
    be = '\033[0m'
    parser = argparse.ArgumentParser(
        description="Create a 'MDTO Bestand' .xml file based on the characteristics of your input FILE.\n"
        'The value of most XML tags will be inferred automatically, but some need to be specified manually.\n\n'
        f'{bb}Example:{be} mdto img001.jpg --identificatiekenmerk 34c5-43a --identificatiebron "Corsa (DMS)" --informatieobject 103.xml',
        formatter_class=argparse.RawTextHelpFormatter,
        epilog="For more information, see https://www.nationaalarchief.nl/archiveren/mdto/bestand")

    parser.add_argument('infile', metavar='FILE', type=argparse.FileType('r'),
                        help='file for which a MDTO Bestand .xml file should be generated')
    parser.add_argument('--identificatiekenmerk', '-k', metavar='KENMERK', required=True,
                        action='append',
                        help='value of <identificatieKenmerk>. Can be specified multiple times')
    parser.add_argument('--identificatiebron', '-b', metavar='BRON', required=True,
                        action='append',
                        help='value of <identificatieBron>. Can be specified multiple times')
    parser.add_argument('--informatieobject', '-O', metavar="INFORMATIEOBJECT.xml", required=True,
                        type=argparse.FileType('r'),
                        help='path to corresponding informatieobject. '
                        'Used to infer values of <isRepresentatieVan>')

    # optionals
    # nargs='?' means 'use value of default when nothing given'
    parser.add_argument('--output', '-o', metavar="OUTPUT.xml", nargs='?',
                        type=argparse.FileType('w'), default=sys.stdout,
                        help='file to write to (default: print to stdout)')
    parser.add_argument('--url', '-u',
                        help='value of <URLBestand>. Needs to be a RFC 3986 compliant URI')
    parser.add_argument('--naam', '-n',
                        help='override <naam> with custom value')
    parser.add_argument('--quiet', '-q', action='store_true',
                        help='silence non-fatal warnings')
    parser.add_argument('--force', '-f', action='store_true',
                        help="do not exit when a tag's value conflicts with the MDTO spec. "
                        "Might produce non-compliant files")

    args = parser.parse_args()

    bestand = Bestand(infile=args.infile, identificatiekenmerken=args.identificatiekenmerk,
                      identificatiebronnen=args.identificatiebron,
                      informatieobject=args.informatieobject, naam=args.naam, url=args.url,
                      quiet=args.quiet, force=args.force)
