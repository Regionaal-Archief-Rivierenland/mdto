#!/bin/python

import sys
import os
from typing import TextIO, List
import shutil
import subprocess

# Make into an optional dependency?
import validators

# TODO
# - [x] vraag Leon naar verschillende IDs bij Bestand & Informatieobject
# - [x] python library rfc3987: may seem useful, but too permissive
# - [ ] Nederlandse (+engelse?) documentatie, en het script in het Engels
#   - make a nice ascii cast!
# - [ ] URL validation
# - [ ] try siegfried instead of fido for speed?
#   -  https://openpreservation.org/blogs/siegfried-pronom-based-file-format-identification-tool/
# - [ ] create getter/setter methods for isrepresentatievan info
# - [x] check length of naam
# - [ ] make sure to allow multiple values when "unbounded"
# - [ ] fish/bash autocomplete
#   - i think the best approach is supply these as files on git
#   - this might be useful https://github.com/kislyuk/argcomplete
# - [ ] make a informatieobject subclass, and Object parent class
#   - This way, the script becomes more useful, as it can also generate other .xml files
# - [ ] write unit tests
# - [ ] write setup.py script

MAX_NAAM_LENGTH = 80

class IdentificatieGegevens:
    """MDTO identificatieGegevens class

    MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/identificatieGegevens
    """
    def __init__(self, identificatieKenmerk: str, identificatieBron: str):
        """Create a new identificatieGegevens object"""

        self.identificatieKenmerk = identificatieKenmerk
        self.identificatieBron = identificatieBron

    def __str__(self):
        return self.generate_xml()

    def generate_xml(self):
        """Transform object into XML tree

        Returns:
            XML object
        """
        return ""


class VerwijzingGegevens:
    """MDTO verwijzingGegevens class

    MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/verwijzingGegevens
    """
    def __init__(self,  verwijzingNaam: str, 
                 verwijzingIdentificatie: IdentificatieGegevens = None):
        """Create a new verwijzingGegevens object"""

        self.verwijzingNaam = verwijzingNaam
        self.verwijzingIdentificatie = verwijzingIdentificatie

    def __str__(self):
        return self.generate_xml()

    def generate_xml(self):
        """Transform object into XML tree

        Returns:
            XML object
        """
        return ""


class BegripGegevens:
    """MDTO begripGegevens class

    MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/begripGegevens
    """

    def __init__(self, 
                 begripLabel: str, 
                 begripBegrippenlijst: VerwijzingGegevens,  
                 begripCode: str = None):
        """Create a new BegripGegevens object"""

        self.begripLabel = begripLabel
        self.begripBegrippenlijst = begripBegrippenlijst
        self.begripCode = begripCode

    def __str__(self):
        return self.generate_xml()

    def generate_xml(self):
        """Transform object into XML tree

        Returns:
            XML object
        """
        return ""

class Bestand:
    """MDTO Bestand class"""

    def __init__(self,
                 infile: TextIO,
                 identificatiekenmerken: List[str] | str,
                 identificatiebronnen: List[str] | str,
                 informatieobject: TextIO,
                 naam: str = None,
                 url: str = None,
                 quiet: bool = False,
                 force: bool = False):
        """Create a new Bestand object.

        Args:
            infile: file-like object that serves as the input file
            identificatiekenmerken: str or list of str for <identificatieKenmerk> tags
            identificatiebronnen: str or list of str for <identificatieBron> tags
            informatieobject: file-like object serving as corresponding informatieobject
            naam: value of <naam>. Defaults to the basename of the input file
            url: value of <URLBestand>
            quiet: silence non-fatal warnings
            force: do not exit when encountering invalid tag values
        """

        if quiet:
            self.log = lambda: None
        else:
            self.log = lambda m: print(m, file=sys.stderr)

        self.force = force
        

        self.identificatiekenmerken = identificatiekenmerken
        self.identificatiebronnen = identificatiebronnen

        if len(self.identificatiekenmerken) != len(self.identificatiebronnen):
            self.error("number of 'identificatieKenmerk' tags differs from "
                       "number of 'identificatieBron' tags")
        if naam:
            self.naam = naam
        else:
            self.naam = os.path.basename(infile.name)

        self.url = url

        self.omvang = os.path.getsize(infile.name)
        self.bestandsformaat = self.pronominfo(infile.name)

    def __str__(self):
        # TODO: maybe something more useful?
        return self.generate_xml()

    def generate_xml(self):
        """Transform object into XML tree

        Returns:
            XML object
        """
        return ""

    def pronominfo(self, path: str) -> BegripGegevens:
        # FIXME: format more properly
        """Use fido library to generate PRONOM information about a file.
        This information can be used in the <bestandsformaat> tag.

        Args:
            path: the file to inspect

        Returns:
            ``BegripGegevens`` object with the following properties::
                {
                    `begripLabel`: file's PRONOM signature name
                    `begripCode`: file's PRONOM ID
                    `begripBegrippenLijst`: reference to PRONOM registry
                }
        """

        # Note: fido currently lacks a public API
        # Hence, the most robust solution is to invoke fido as a cli program
        # Upstream issue: https://github.com/openpreserve/fido/issues/94
        # downside is that this is slow, maybe siegfried speeds things up?

        # check if fido program exists
        if not shutil.which('fido'):
            self.error("'fido' not found. For installation instructions, "
                       "see https://github.com/openpreserve/fido#installation")

        cmd = ['fido', '-q', '-matchprintf', 'OK,%(info.formatname)s,%(info.puid)s,\n',
               '-nomatchprintf', 'FAIL', path]
        cmd_result = subprocess.run(cmd, capture_output=True,
                                    shell=False, text=True, check=True)
        breakpoint()
        if cmd_result.returncode != 0:
            self.warn(f"fido PRONOM detection on file {path} "
                      f"failed with error '{cmd_result.stderr}'.")
        elif cmd_result.stdout.startswith("OK"):
            results = cmd_result.stdout.split('\n')
            if len(results) > 2: # .split('\n') returns a list of two elems
                self.log("Info: fido returned more than one PRONOM match "
                         f"for file {path}. Selecting the first one.")
            # strip "OK" from the output
            results = results[0].split(",")[1:]
            verwijzing = VerwijzingGegevens(verwijzingNaam="PRONOM-register")
            return BegripGegevens(begripLabel=results[0],
                                  begripCode=results[1],
                                  begripBegrippenlijst=verwijzing)
        else:
            self.warn(f"fido failed to detect PRONOM ID of file {path}.")

        # can return None in case PRONOM detection fails and force == True
        return None

    @property
    def naam(self):
        """Value of MDTO 'naam' tag.

        Defaults to: the name of the input file.
        Valid value: any string of up to 80 characters in length
        MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/naam
        """
        return self._naam

    @naam.setter
    def naam(self, val):
        if len(val) > MAX_NAAM_LENGTH:
            self.warn(f"value '{val}' of attribute 'naam' "
                      "exceeds maximum length of {MAX_NAAM_LENGTH}")
        self._naam = val

    @property
    def identificatiekenmerken(self):
        """Value(s) of MDTO 'identificatieKenmerk' tag(s).

        Valid value(s): any string or list of strings
        MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/identificatieKenmerk
        """
        return self._identificatiekenmerken

    @identificatiekenmerken.setter
    def identificatiekenmerken(self, val):
        # Note that, here, there's no check if len(kenmerken) matches len(bronnen).
        # However, such a check  might not be useful anyway,
        # as self.kenmerken and self.bronnen cannot be updated simultaneously.
        # Lets just that hope validation checks against the .xsd catch this.

        # permits setting this to a string
        if isinstance(val, str):
            self._identificatiekenmerken = [val]
        elif isinstance(val, list):
            self._identificatiekenmerken = val
        else:
            self.error(f"{type(val)} is not a valid type for <identificatieKenmerk>")

    @property
    def identificatiebronnen(self):
        """Value(s) of MDTO 'identificatieBron' tag(s).

        Valid value(s): any string or list of strings
        MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/identificatieBron
        """
        return self._identificatiebronnen

    @identificatiebronnen.setter
    def identificatiebronnen(self, val):
        # permits setting this to a string
        if isinstance(val, str):
            self._identificatiebronnen = [val]
        elif isinstance(val, list):
            self._identificatiebronnen = val
        else:
            self.error(f"{type(val)} is not a valid type for <identificatieBron>")

    @property
    def url(self):
        """Value of MDTO 'URLBestand' tag.

        Valid value: any RFC 3986 compliant URI
        MDTO docs: https://www.nationaalarchief.nl/archiveren/mdto/URLBestand
        """
        return self._url

    @url.setter
    def url(self, val):
        # url can be non-existant
        if val is None:
            self._url = None
        elif validators.url(val):
            self._url = val
        else:
            self.warn(f"URL {val} is malformed.")

    # Helper methods
    def warn(self, warning):
        """Print warning, and exit if self.force is not set"""

        orange = '\033[33m'
        esc_end = '\033[0m'

        warning = f"{orange}Warning: {warning} "
        warning += "Skipping." if self.force else "Exiting."
        warning += esc_end

        self.log(warning)
        if not self.force:
            sys.exit(-1)

    def error(self, error):
        """Print error and exit"""

        red = '\033[31m'
        esc_end = '\033[0m'

        self.log(f"{red}Error: {error}{esc_end}")
        sys.exit(-1)
        
if __name__ == "__main__":

    import argparse

    bb = '\033[1m'
    be = '\033[0m'
    parser = argparse.ArgumentParser(
        description="Create a 'MDTO Bestand' .xml file based on the characteristics of your input FILE.\n"
        'The value of most XML tags will be inferred automatically, but some need to be specified manually.\n\n'
        f'{bb}Example:{be} mdto img001.jpg --identificatiekenmerk 34c5-43a --identificatiebron "Corsa (DMS)" --informatieobject 103.xml',
        formatter_class=argparse.RawTextHelpFormatter,
        epilog="For more information, see https://www.nationaalarchief.nl/archiveren/mdto/bestand")

    parser.add_argument('infile', metavar='FILE', type=argparse.FileType('r'),
                        help='file for which a MDTO Bestand .xml file should be generated')
    parser.add_argument('--identificatiekenmerk', '-k', metavar='KENMERK', required=True,
                        action='append',
                        help='value of <identificatieKenmerk>. Can be specified multiple times')
    parser.add_argument('--identificatiebron', '-b', metavar='BRON', required=True,
                        action='append',
                        help='value of <identificatieBron>. Can be specified multiple times')
    parser.add_argument('--informatieobject', '-O', metavar="INFORMATIEOBJECT.xml", required=True,
                        type=argparse.FileType('r'),
                        help='path to corresponding informatieobject. '
                        'Used to infer values of <isRepresentatieVan>')

    # optionals
    # nargs='?' means 'use value of default when nothing given'
    parser.add_argument('--output', '-o', metavar="OUTPUT.xml", nargs='?',
                        type=argparse.FileType('w'), default=sys.stdout,
                        help='file to write to (default: print to stdout)')
    parser.add_argument('--url', '-u',
                        help='value of <URLBestand>. Needs to be a RFC 3986 compliant URI')
    parser.add_argument('--naam', '-n',
                        help='override <naam> with custom value')
    parser.add_argument('--quiet', '-q', action='store_true',
                        help='silence non-fatal warnings')
    parser.add_argument('--force', '-f', action='store_true',
                        help="do not exit when a tag's value conflicts with the MDTO spec. "
                        "Might produce non-compliant files")

    args = parser.parse_args()

    bestand = Bestand(infile=args.infile, identificatiekenmerken=args.identificatiekenmerk,
                      identificatiebronnen=args.identificatiebron,
                      informatieobject=args.informatieobject, naam=args.naam, url=args.url,
                      quiet=args.quiet, force=args.force)
